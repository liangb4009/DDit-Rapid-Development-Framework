# -*- coding: UTF-8 -*-
# @create by marick, 2018-07-09
# 识别瑕疵
# 导入必要的软件包
import cv2
import os
import numpy as np


class ReadDefects(object):
    def __init__(self, parent):
        self.parent = parent;
        self.min_area = 500
        self.max_area = 650
        self.rtnAreas = []

    def start(self):
        print 'start'
        if self.parent.camera != None: print self.parent.camera
        if self.parent.srcFolderPath != None: print self.parent.srcFolderPath
        if self.parent.backGround != None: print self.parent.backGround
        if self.parent.roi != None: print self.parent.roi
        if self.parent.white != None: print self.parent.white

    #识别瑕疵
    #传入参数
    #backGround，背景图像
    #toCheck，要检测图像
    #返回值
    #返回值1，True表示检测到瑕疵，False表示没有检测到瑕疵
    #返回值2，包含所有瑕疵区域列表，举例[(1,1,20,20),(2,2,30,30)]，返回两个瑕疵，第一个瑕疵坐标(1,1,20,20)，第二个瑕疵坐标(2,2,30,30)
    #算法简介：
    #将背景图像和要检测图像设置成灰度图像
    #将灰度背景图像和灰度要检测图像做绝对值减法获得差异图像
    #将图像做索贝尔变换获得图像边缘
    #将图像扩充，扩充后图像具有更好封闭性
    #发现图像轮廓
    #过滤小轮廓，将轮廓增加到瑕疵区域列表，返回给调用者
    def checkDefects(self, backGround, toCheck):
        result = False
        rtnRegions = []
        # 将背景图像和要检测图像设置成灰度图像
        backGround = cv2.cvtColor(backGround, cv2.COLOR_BGR2GRAY)
        toCheck = cv2.cvtColor(toCheck, cv2.COLOR_BGR2GRAY)
        # 将灰度背景图像和灰度要检测图像做绝对值减法获得差异图像
        gray = cv2.absdiff(backGround, toCheck)
        #cv2.imshow("gray",gray)
        # 将图像做索贝尔变换获得图像边缘
        # ddepth = cv2.CV_32F
        # gradX = cv2.Sobel(gray, ddepth=ddepth, dx=1, dy=0, ksize=-1)
        # gradY = cv2.Sobel(gray, ddepth=ddepth, dx=0, dy=1, ksize=-1)
        # gradient = cv2.subtract(gradX, gradY)
        # gradient = cv2.convertScaleAbs(gradient)
        # cv2.imshow("gradient",gradient)
        thresh = cv2.threshold(gray, 100, 255, cv2.THRESH_BINARY)[1]
        #cv2.imshow("thresh",thresh)
        # 将图像扩充，扩充后图像具有更好封闭性
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
        thresh = cv2.dilate(thresh, kernel, iterations=3)
        #cv2.imshow("thresh2",thresh)
        # 发现图像轮廓
        image, contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for contour in contours:
            # 过滤小轮廓
            if cv2.contourArea(contour) <= self.min_area or cv2.contourArea(contour) >= self.max_area:
                continue
            self.rtnAreas.append(cv2.contourArea(contour))
            result = True
            min = np.nanmin(contour, 0)
            max = np.nanmax(contour, 0)
            #将轮廓增加到瑕疵区域列表，返回给调用者
            rtnRegions.append((min[0][0], min[0][1], max[0][0], max[0][1]))
        print rtnRegions
        return result,rtnRegions

    def stop(self):
        print 'stop'

    def quit(self):
        print 'quit'

