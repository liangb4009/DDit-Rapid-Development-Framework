# -*- coding: UTF-8 -*-
# @create by marick, 2018-07-06
# 识别瓶子
# 导入必要的软件包
import cv2
import os

class ReadBottle(object):
    def __init__(self, parent):
        self.parent=parent;
        #过滤小轮廓
        self.min_area=60000
    def start(self):
        print 'start'
        if self.parent.camera != None: print self.parent.camera
        if self.parent.srcFolderPath !=None: print self.parent.srcFolderPath
        if self.parent.backGround != None: print self.parent.backGround
        if self.parent.roi != None: print self.parent.roi
    #返回输入图片img的RoiRegion，
    #返回值,举例：(10,20,30,40)
    #其中(10,20)是左上角x,y
    #(30,40)是右下角x,y
    #计算过程如下:
    #self.parent.backGround图片转换为灰度图片backgroundGray
    #img图片转换为灰度图片imgGray
    #计算backgroundGray和imgGray的不同存储为imgDelta
    #计算imgDelta的二值化图片thresh
    #对thresh执行膨胀操作
    #对thresh发现轮廓
    #遍历所有轮廓，过滤掉较小轮廓min_area
    #计算轮廓的中心cX,cY
    #计算img的宽度w,高度h
    #返回(cX-w/2,cY-h/2,cX+w/2,cY+h/2)作为RoiRegion
    def recognizeRoiRegion(self,img):
        rtn = (0,0,0,0)
        background = cv2.imread(os.path.abspath(os.path.join(self.parent.srcFolderPath,self.parent.backGround)))
        resize = cv2.resize(background, (640,480), interpolation=cv2.INTER_CUBIC)
        backgroundGray = cv2.cvtColor(resize,cv2.COLOR_RGB2GRAY)
        resize = cv2.resize(img, (640,480), interpolation=cv2.INTER_CUBIC)
        imgGray = cv2.cvtColor(resize,cv2.COLOR_RGB2GRAY)
        imgDelta = cv2.absdiff(backgroundGray,imgGray)
        thresh = cv2.threshold(imgDelta,25,255,cv2.THRESH_BINARY)[1]
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3,3))
        thresh = cv2.dilate(thresh,kernel,iterations=3)
        image, cnts, hierarchy = cv2.findContours(thresh.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
        roi = cv2.imread(os.path.abspath(os.path.join(self.parent.srcFolderPath,self.parent.backGround)))
        h = roi.shape[0]
        w = roi.shape[1]
        for c in cnts:
            if cv2.contourArea(c) <= self.min_area:
                continue
            M = cv2.moments(c)
            cX = int(M["m10"]/M["m00"])
            cY = int(M["m01"]/M["m00"])
            rtn = (cX-w/2,cY-h/2,cX+w/2,cY+h/2)
        return rtn
    #返回输入图片img的RoiRegion，
    #返回值,举例：(10,20)
    #其中(10,20)是Roi的中心的x,y
    #计算过程如下:
    #self.parent.backGround图片转换为灰度图片backgroundGray
    #img图片转换为灰度图片imgGray
    #计算backgroundGray和imgGray的不同存储为imgDelta
    #计算imgDelta的二值化图片thresh
    #对thresh执行膨胀操作
    #对thresh发现轮廓
    #遍历所有轮廓，过滤掉较小轮廓min_area
    #计算轮廓的中心cX,cY
    #返回(cX,cY)作为RoiCenter
    def recognizeRoiCenter(self,img):
        rtn = (0,0,0,0)
        background = cv2.imread(os.path.abspath(os.path.join(self.parent.srcFolderPath,self.parent.backGround)))
        resize = cv2.resize(background, (640,480), interpolation=cv2.INTER_CUBIC)
        backgroundGray = cv2.cvtColor(resize,cv2.COLOR_RGB2GRAY)
        resize = cv2.resize(img, (640,480), interpolation=cv2.INTER_CUBIC)
        imgGray = cv2.cvtColor(resize,cv2.COLOR_RGB2GRAY)
        imgDelta = cv2.absdiff(backgroundGray,imgGray)
        thresh = cv2.threshold(imgDelta,25,255,cv2.THRESH_BINARY)[1]
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3,3))
        thresh = cv2.dilate(thresh,kernel,iterations=3)
        image, cnts, hierarchy = cv2.findContours(thresh.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
        roi = cv2.imread(os.path.abspath(os.path.join(self.parent.srcFolderPath,self.parent.backGround)))
        h = roi.shape[0]
        w = roi.shape[1]
        for c in cnts:
            if cv2.contourArea(c) <= self.min_area:
                continue
            M = cv2.moments(c)
            cX = int(M["m10"]/M["m00"])
            cY = int(M["m01"]/M["m00"])
            rtn = (cX,cY)
        return rtn
    def stop(self):
        print 'stop'
    def quit(self):
        print 'quit'

